scalar Date
scalar Url

# enum
enum OrderBy {
  asc
  desc
}

enum WebtoonOrderByField {
  title
}

enum CollectionOrderByField {
  title
  updatedAt
}

enum Platform {
  NAVER
  DAUM
}

# interface
interface Node {
  id: ID!
}

interface Connection {
  edges: [Edge]
  pageInfo: PageInfo!
  totalCounts: Int!
  counts: Int!
}

interface Edge {
  cursor: String!
  node: Node
}

# types
type Query {
  authors(first: Int, last: Int, before: ID, after: ID): AuthorConnection!
  webtoons(first: Int, last: Int, before: ID, after: ID): WebtoonConnection!
  collections(
    first: Int
    last: Int
    before: ID
    after: ID
    keyword: String
  ): CollectionConnection!
  genres: [Genre]
  users(first: Int, last: Int, before: ID, after: ID): UserConnection!
  user(id: ID!): User!
  # myProfile(id: ID!): User!
  webtoon(id: ID!): Webtoon!
  randomWebtoons(take: Int = 1): [Webtoon!]
  search(keyword: String, where: SearchFiltering): SearchResultConnection!
}

type Mutation {
  login(input: LoginInput!): AuthPayload!
  signup(input: SignupInput!): AuthPayload!
  createCollection(input: CollectionInput!): Collection!
}

type AuthPayload {
  token: String
  user: User
}

type PageInfo {
  startCursor: String
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
}

# nodes
type Webtoon implements Node {
  id: ID!
  title: String!
  description: String!
  platform: Platform!
  isFinish: Boolean!
  isAdult: Boolean!
  isPay: Boolean!
  thumbnail: Url!
  url: Url!
  authorsConnection(
    first: Int
    last: Int
    before: ID
    after: ID
  ): WebtoonAuthorsConnection!
  collectionsConnection(
    first: Int
    last: Int
    before: ID
    after: ID
  ): WebtoonCollectionsConnection!
  genres: [Genre!]
  comments: [Comment]
}

type Author implements Node {
  id: ID!
  name: String!
  webtoonsConnection(
    first: Int
    last: Int
    before: ID
    after: ID
  ): AuthorWebtoonsConnection!
}

type Genre {
  code: String!
  name: String!
  webtoonsConnection(
    first: Int
    last: Int
    before: ID
    after: ID
  ): GenreWebtoonsConnection!
}

type Collection implements Node {
  id: ID!
  title: String!
  description: String!
  webtoonsConnection(
    first: Int
    last: Int
    before: ID
    after: ID
  ): CollectionWebtoonsConnection!
  writer: User!
  createdAt: Date!
  updatedAt: Date
}

type User implements Node {
  id: ID!
  email: String!
  name: String!
  password: String!
  # likedWebtoon
  collectionsConnection(
    first: Int
    last: Int
    before: ID
    after: ID
  ): UserCollectionsConnection!
  comments: [Comment]
}

type Comment {
  message: String!
  writer: User!
  writtenWebtoon: Webtoon!
  subComments: [Comment]
}

# query connections
type UserConnection implements Connection {
  edges: [UserEdge]
  pageInfo: PageInfo!
  totalCounts: Int!
  counts: Int!
}

type WebtoonConnection implements Connection {
  edges: [WebtoonEdge]
  pageInfo: PageInfo!
  totalCounts: Int!
  counts: Int!
}

type CollectionConnection implements Connection {
  edges: [CollectionEdge]
  pageInfo: PageInfo!
  totalCounts: Int!
  counts: Int!
}

type AuthorConnection implements Connection {
  edges: [AuthorEdge]
  pageInfo: PageInfo!
  totalCounts: Int!
  counts: Int!
}

type WebtoonAuthorsConnection implements Connection {
  edges: [WebtoonAuthorsEdge]
  pageInfo: PageInfo!
  totalCounts: Int!
  counts: Int!
}

type WebtoonCollectionsConnection implements Connection {
  edges: [WebtoonCollectionsEdge]
  pageInfo: PageInfo!
  totalCounts: Int!
  counts: Int!
}

type AuthorWebtoonsConnection implements Connection {
  edges: [AuthorWebtoonsEdge]
  pageInfo: PageInfo!
  totalCounts: Int!
  counts: Int!
}

type CollectionWebtoonsConnection implements Connection {
  edges: [CollectionWebtoonsEdge]
  pageInfo: PageInfo!
  totalCounts: Int!
  counts: Int!
}

type GenreWebtoonsConnection implements Connection {
  edges: [GenreWebtoonsEdge]
  pageInfo: PageInfo!
  totalCounts: Int!
  counts: Int!
}

type SearchResultWebtoonConnection implements Connection {
  edges: [SearchResultWebtoonEdge]
  pageInfo: PageInfo!
  totalCounts: Int!
  counts: Int!
}

type SearchResultCollectionConnection implements Connection {
  edges: [SearchResultCollectionEdge]
  pageInfo: PageInfo!
  totalCounts: Int!
  counts: Int!
}

type UserCollectionsConnection implements Connection {
  edges: [UserCollectionsEdge]
  pageInfo: PageInfo!
  totalCounts: Int!
  counts: Int!
}

# other connections
type SearchResultConnection {
  webtoonResult(
    first: Int
    last: Int
    before: ID
    after: ID
  ): SearchResultWebtoonConnection
  collectionResult(
    first: Int
    last: Int
    before: ID
    after: ID
  ): SearchResultCollectionConnection
}

# edges
type WebtoonEdge implements Edge {
  cursor: String!
  node: Webtoon
}

type CollectionEdge implements Edge {
  cursor: String!
  node: Collection
}

type AuthorEdge implements Edge {
  cursor: String!
  node: Author
}

type WebtoonAuthorsEdge implements Edge {
  cursor: String!
  node: Author
}

type WebtoonCollectionsEdge implements Edge {
  cursor: String!
  node: Collection
}

type AuthorWebtoonsEdge implements Edge {
  cursor: String!
  node: Webtoon
}

type CollectionWebtoonsEdge implements Edge {
  cursor: String!
  node: Webtoon
}

type GenreWebtoonsEdge implements Edge {
  cursor: String!
  node: Webtoon
}

type SearchResultWebtoonEdge implements Edge {
  cursor: String!
  node: Webtoon
}

type SearchResultCollectionEdge implements Edge {
  cursor: String!
  node: Collection
}

type UserEdge implements Edge {
  cursor: String!
  node: User
}

type UserCollectionsEdge implements Edge {
  cursor: String!
  node: Collection
}

# input
input SignupInput {
  name: String!
  email: String!
  password: String!
}

input LoginInput {
  email: String!
  password: String!
}

input CollectionInput {
  title: String!
  description: String!
  webtoons: [String!]!
}

input SearchFiltering {
  isPay: Boolean
  isAdult: Boolean
  isFinish: Boolean
  platforms: [Platform]
  genres: [String]
}
